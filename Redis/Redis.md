# Redis

## 常见问题

### Redis 延时队列

使用 `sortedset` , 时间戳作为 score, 消息内容作为key, 调用zadd来生产消息, 通过 zrangebyscore 来获取范围内的消息

### Redis 做异步队列

使用 `list` 来做异步队列, rpush生产消息, lpop消费消息, 缺点在于消费者挂掉时, 消息会丢失, 所以推荐使用 `rabbitMQ` 等专业队列. 当没有消息时, 需要sleep一段时间, 或者使用 blpop 在没有消息时, 会一直阻塞住.
还可以通过 `sub/pub`主题订阅模式, 达到一个消息多次消费的效果. 消费者下线后, 消息也会丢失.

### Redis 查大量数据

假设Redis中有1亿数据, 其中有10w条数据key的前缀是相同的, 如何查阅这些数据?
由于redis是单线程的, 当有业务在运行时, 直接使用keys命令会导致一段时间的不可用, 所以推荐使用 scan 命令, 虽然会查出来一定的重复key, 但是可以在客户端去重即可, 这样对生产的影响会降低.

### Redis 有哪些数据结构

`String`

字符串, 单个key最大储存 512M

`List`

列表

`Hash`

哈希

`Set`

无须集合

`Sort Set`

有序集合

`Pub/Sub`

订阅消费者模式

`Geo`

储存地理位置, 可以计算两个地理点的3D距离

`HyperLogLog` 

基数统计算法, 是一种概率算法, 用来统计大量的数据的统计结果, 并不储存具体的键. 在 redis 中, 只需要 12k 内存就可以储存理论上接近 2^64 个不同元素的基数. 在储存的元素数量或者体积非常大时, 使用的空间总是固定的, 并且是很小的.

应用: 一般用于统计注册IP数, 每日页面访问数等

### Redis 数据淘汰策略

系统默认 `no-eviction`

1. `voltile-lru` 在设置了过期时间的数据中, 淘汰最近最少使用的数据
2. `voltile-ttl` 淘汰将设置了过期时间的数据, ttl大的优先淘汰 (即最接近过期的)
3. `voltile-random` 随机淘汰设置了过期时间的数据
4. `allkeys-lru` 淘汰最近最少使用的数据
5. `allkeys-random` 任意选择淘汰
6. `no-eviction` 禁止淘汰, 当内存不足时写入数据, 会返回错误

### Redis 三种淘汰机制

1. `LRU (Least recently used 最近最少使用) `
2. `TTL`
3. `Random`

### Redis 持久化策略

1. `RDB `

全量备份, 备份慢, 恢复快

2. `AOF (Append only file)` 

记录所有的写操作(增删)

增量备份, 备份快, 恢复慢

当备份文件大于原数据集时, 会重写文件

### Redis 订阅发布机制

两种订阅模式:

1. `channel` 频道订阅模式, 例如订阅了 A 频道, 则 A 频道发布消息时, 订阅者都可以收到
2. `pattern` glob-style 模式, 及匹配模式, 例如订阅了 *.news, China.news, America.news 发布消息时, 订阅了这个频道的人都会收到

### Redis 主从复制

### Redis 性能优化

1. master 最好不做持久化工作, 交给 slave 来做
2. 为了主从复制的速度和连接的稳定性, master 和 slave 最好在同一个局域网内
3. 尽量避免在压力大的主库上增加从库
4. 主从复制尽量不采用网状结构, 而是线性结构, master->slave1->slave2->...

### 缓存与数据库数据不一致怎么办

假设使用的主存分离, 读写分离的数据库.

发生的可能性: 

1. 主库更新数据, 主库到从库的同步未完成, 从库读取数据, 未读到最新数据, 而更新了缓存

解决方案: 在从库接收到数据更新操作时, 淘汰掉这条数据的缓存

解决方案: 

1. 在数据性一致性要求不高时, 忽略掉这个数据的不一致
2. 延时双删策略
    1. 先删除缓存
    2. 再写数据库
    3. 休眠500毫秒
    4. 再次删除缓存
    5. 设置缓存过期时间
4. 异步更新缓存(基于订阅binlog的同步机制)
    1. Redis订阅 mysql binlog消息
    2. 依据消息来进行相关操作
    
### Redis 缓存穿透

起因: 恶意请求故意大量查询不存在的key, 让请求到达MySQL, 对后端造成很大压力
解决方案: 对不存在的key也做有有效期的缓存; 对存在的key放到一个bitmap来储存, 查询时通过bitmap过滤.

### Redis 缓存雪崩

起因: 大量的缓存在同一时间段失效, 导致后端压力大.
解决方案: 对缓存的有效时间使用不同的过期时间; 做二级缓存; 

### Redis 主从复制的实现

1. 主节点将内存中的数据做一个快照, 发送给从节点, 从节点将数据恢复到内存中.
2. 之后每次增加新数据, 主节点以类似 mysql 的二进制日志方式将语句发送给从节点, 从节点拿到主节点发送过来的语句进行重放.

### Redis 分布式锁

> 为什么要分布式锁

为了确保在多个线程中, 多服务器中执行任务时, 能够达到一致性

> Redis 为什么可以做分布式锁

Redis 是单线程的(网络请求模块使用了一个线程, 所以不需要考虑并发性), 即一个线程处理所有网络请求, 其它模块仍用了多个线程.

> 如何用

使用 `setnx key value`即加锁, 其它线程再来设置会返回false
`del key` 释放锁

> 解决死锁

1. Redis控制: 使用 `setnx key value` 后, 立即使用 `expire key timeout` 设置有效期.
2. 其它服务器控制: 通过 `value` 设置为失效时的时间戳(比如当前+1s), 其它服务器在获取锁时发现锁还在, 且超过了有效期, 就直接来释放锁, 在释放锁这个过程, 需要使用 `GETSET key value` 来操作, 直接对这个key进行`getset`, 看返回值如果是过期的, 说明拿到了锁, 反之拿失败了. 拿失败的情况下, 需要放弃后续的操作了

> 缺陷

当master上加了锁, 还未同步到 slave 时, master down了, 这个时候 slave 成为了 master, 其中并没有锁, 这个时候就会出现多个客户端同时拿到锁的问题.

> 锁延期机制 (watch dog)

当客户端超过了key的生存时间还在操作, 想要继续有这个锁, 那么可以使用看门狗程序, 在生存时间内会定时查这个锁是否还在, 还在的话就延期

### Redis 做内存优化

1. 尽可能使用散列表

### Redis key 过期时间和永久有效设置

设置过期时间 `EXPIRE key seconds`
设置永久有效 `PERSIST key`

### Redis 事务

Redis事务保证了命令的打包操作, 其中的一个命令失败不会回滚, 也不会影响下一个命令的执行, 只是打包操作了, 保证了在执行过程中, 不会有其它命令的插入

使用 `MULTI` 开始一个事务
使用 `EXEC` 执行事务

### Redis 管道

一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应,这样就可以将多个命令发送到服务器, 而不用等待回复, 最后在一个步骤中读取该答复.

### Redis 集群

> 集群最大节点数

16384个

> 集群之间是如何复制的

异步复制

### Redis 应用

- 队列 (List)
- 排行榜/计数器 (SortedSet)
- 全页缓存 (FPC) 缓存页面
- 会话缓存 (缓存Session)

### Redis 为什么把数据都放在内存中

为了达到最快的读写速度, 并通过异步的方式将数据写入磁盘.

磁盘 I/O 会严重影响 redis 的性能



